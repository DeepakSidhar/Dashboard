import logging
import nvdlib #(Donato, 2025)
import  datetime
import psycopg2 # (Vishal, 2018)
import os

#set up logger
logging.basicConfig(
        format='[%(asctime)s] %(levelname)s: %(message)s',
        level=logging.INFO,
        filename='cve-scaner.log',
        encoding='utf-8'
    )
#Add logging to console also
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
logging.getLogger().addHandler(console_handler)
logger = logging.getLogger()
API_KEY = os.environ.get('API_KEY','eb1fd457-a957-419d-a6ed-e8aab63bad85') # api key is access NVD either from prod os files or default
DB_CONN_STRING = os.environ.get('DB_CONN_STRING', "dbname=dashboard_db user=postgres password=postgres1 host=localhost port=5433")

def main():
    with  psycopg2.connect(DB_CONN_STRING) as conn: # using the with close the file manamgent .
        with conn.cursor() as cur:
            create_log_table(cur)  # Creating the table if not present
            last_run = get_last_run(cur)  # getting the last run date if its there
            now = datetime.datetime.now(datetime.UTC)
            # if last run date is present is  will assign to the start date.
            if last_run:
                start_date = last_run
                logger.info(f"Last run was {last_run}")
            else:
                start_date = now -  datetime.timedelta(days=120) # 120  is the limit
                logger.info(f"NO Last run found. fetching 120 days {last_run}")

            vulnerabilities = fetch_vulnerabilities(start_date, now) # This is using the calulation and fetching the vulnerabilityes
            logger.info(f"Getting vulnerabilities :{len(vulnerabilities)}")
            insert_into_database(vulnerabilities, cur) #  This inserts the vulnerabilities into the database
            log_current_run(cur)# adding the new date to the datebase

            conn.commit()
            logger.info(f"Inserted vulnerabilities to the database  :{len(vulnerabilities)}")


#Start date wuth type datetime
#End date wuth type datetime
def fetch_vulnerabilities(start_date: datetime.datetime,end_date: datetime.datetime):
    vulnerabilities = []
    logger.info(f"Fetching CVEs since {start_date}")
    start_date_str = start_date.strftime("%Y-%m-%d %H:%MZ")#formatting the start date tp string to add the Z allowing us get data using the nvdlib
    end_date_str = end_date.strftime("%Y-%m-%d %H:%MZ")#formatting the endstart date tp string to add the Z allowing us get data using the nvdlib

    results = nvdlib.searchCVE(pubStartDate=datetime.datetime.fromisoformat(start_date_str),
                               pubEndDate=datetime.datetime.fromisoformat(end_date_str),
                               limit=2,  # limit is 2000
                               key=API_KEY) # using the nvdlib api to get the list of vulnerabilities
    logger.info(f"Fetched vulnerabilities from the API  :{len(results)}")
    logger.info(f"Fetched vulnerabilities from the API  :{(results)}")

#this is filering the data returned to ensure we only include cve_id, published_date, last_modified_date, description, severity, cvss_score, vendor, product, version)
    for cve in results:
        if not hasattr(cve, 'configurations'):# check if the config  is present  if not then is ignored
            continue

        for config in cve.configurations:
            for node in config.nodes:
                if not hasattr(node, 'cpeMatch'): # if no cpe match then ignore the data
                    continue

                for cpe_match in node.cpeMatch:
                    cpe_uri = cpe_match.criteria
                    cpe_parts = cpe_uri.split(':')
                    if len(cpe_parts) < 6:
                        continue
                    vendor = cpe_parts[3]
                    product = cpe_parts[4]
                    version = cpe_parts[5]
                    descriptions = cve.descriptions[0].value if cve.descriptions else None # first description
                    severity = cve.score[2] if len(cve.score) >= 3 else None # nvdlib passes this information https://nvdlib.com/en/latest/v1/v1.html
                    cvss_score = cve.score[1]  if len(cve.score) >= 3 else None # nvdlib passes this information https://nvdlib.com/en/latest/v1/v1.html
                    vulnerabilities.append(
                        (cve.id, cve.published, cve.lastModified, descriptions, severity, cvss_score, vendor, product, version)
                    )
    return vulnerabilities
def insert_into_database(vulnerabilities,cur):
    insert_query = """
        INSERT INTO public.vulnerability(
        cve_id, published_date, last_modified_date, description, severity, cvss_score, vendor, product, version)
        VALUES (%s, %s, %s, %s, %s, %s,%s, %s, %s)
        ON CONFLICT (cve_id) DO NOTHING 
    """

    # Execute a query
    cur.executemany(insert_query, vulnerabilities)

#creating the table if not already there
def create_log_table(cur):
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS vulnerability_fetch_log (
            id SERIAL PRIMARY KEY,
            fetched_at TIMESTAMPTZ NOT NULL DEFAULT NOW() 
        )
           
        """
    )
#getting the last run date if stored in the database
def get_last_run(cur):
    cur.execute(
        """
        SELECT fetched_at 
        from vulnerability_fetch_log
        ORDER BY fetched_at DESC
        LIMIT 1
        """
    )
    result = cur.fetchone()
    return result[0] if result else None
#Adding the date of the run now a
def log_current_run(cur):
    cur.execute(
        """
        INSERT INTO  vulnerability_fetch_log  (fetched_at)
        VALUES (NOW() AT TIME ZONE 'UTC')
        """
    )


if __name__ == '__main__':
    main()